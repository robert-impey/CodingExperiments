import unittest

from find_max import find_max

# My original test cases


def test_lists():
    expectations = [([], None), ([1], 1), ([1, 5, 3, 4, 2], 5)]

    for test_input, exp in expectations:
        assert find_max(test_input) == exp


# Generated by Claude 3.5 Sonnet
# With modifications


class TestFindMax(unittest.TestCase):
    def test_find_max_empty_list(self):
        self.assertIsNone(find_max([]))

    def test_find_max_single_element(self):
        self.assertEqual(find_max([5]), 5)

    def test_find_max_positive_integers(self):
        self.assertEqual(find_max([1, 5, 3, 9, 2]), 9)

    def test_find_max_negative_integers(self):
        self.assertEqual(find_max([-5, -2, -10, -1, -7]), -1)

    def test_find_max_mixed_integers(self):
        self.assertEqual(find_max([-3, 4, 0, -1, 8, -5, 2]), 8)

    def test_find_max_largest_at_beginning(self):
        self.assertEqual(find_max([10, 5, 3, 9, 2]), 10)

    def test_find_max_largest_at_end(self):
        self.assertEqual(find_max([1, 5, 3, 9, 12]), 12)

    def test_find_max_duplicate_maximum_values(self):
        self.assertEqual(find_max([5, 3, 8, 2, 8, 1, 8]), 8)

    def test_find_max_floating_point_numbers(self):
        actual = find_max([3.14, 2.718, 1.414, 4.669, 0.577])
        if actual is None:
            self.fail("Expected a float, but got None")
        self.assertAlmostEqual(actual, 4.669)

    def test_find_max_very_large_numbers(self):
        self.assertEqual(find_max([10**9, 10**10, 10**8, 10**11, 10**9 + 1]), 10**11)


if __name__ == "__main__":
    unittest.main()
